---
layout: post
title: "The art of war-python"
subtitle: 'The art of war-python'
author: "Kgod"
header-style: text
tags:
  - Python
--- 

# 数据结构与算法（Python）
*课程参见:<a href="https://www.bilibili.com/video/av21540971/?p=2"> Python 兵法  </a>*

<!-- MarkdownTOC -->

- 一、引入概念
    - 1-01算法引入
    - 1-02 时间复杂度与大O表示法
    - 1-03-最坏时间复杂度与计算规则
    - 1-04-常见时间复杂度与大小关系
    - 1-05-代码执行时间测量模块
    - 1-07-Python列表与字典操作的时间复杂度
    - 1-08-数据结构引入
- 二、顺序表
    - 2-01 内存、类型本质、连续存储
    - 2-02 基本顺序表与元素外围顺序表
    - 2-03 顺序表的一体式结构与分离式结构
    - 2-04 顺序表数据区替换与扩充
    - 2-05 顺序表的操作
    - 2-06 Python中的顺序表
- 三、链表
    - 3-01 链表的提出
    - 3-02 单链表的ADT模型
    - 3-03 Python中变量标识的本质
    - 3-04 单链表及结点的定义代码
    - 4-05 单链表的判空、长度、遍历与尾部添加结点的代码实现
    - 3-06 单链表尾部添加和在指定位置添加
    - 3-07 单链表查找和删除元素
    - 3-08 单链表与顺序表的对比
    - 3-09 单向循环链表遍历和求长度
    - 3-10 单向循环链表添加元素
    - 3-11 单向循环链表删除元素
    - 3-12 单向循环链表删除元素复习及链表扩展
    - 3-13 双向链表及添加元素
    - 3-14 双向链表删除元素
- 四、栈
    - 4-01 栈与队列的概念
    - 4-02 栈的实现
    - 4-03 队列与双端队列的实现
- 五、排序与搜索
    - 5-01 排序算法的稳定性
    - 5-02 冒泡排序及实现
    - 5-03 选择排序算法及实现
    - 5-04 插入算法
    - 5-05 插入排序
    - 5-06 插入排序2
    - 5-07 希尔排序
    - 5-08 希尔排序实现
    - 5-09 快速排序
    - 5-10 快速排序实现1-1
    - 5-10 快速排序实现1
    - 5-11 快速排序实现2
    - 5-12 归并排序
    - 5-13 归并排序 代码执行流程
    - 5-14 归并排序时间复杂度及排序算法复杂度对比
    - 5-15 二分查找
    - 5-16 二分查找时间复杂度
- 六、树和树的算法
    - 6-01 树的概念
    - 6-02 二叉树的概念
    - 6-03 二叉树的广度优先遍历
    - 6-04 二叉树的实现
    - 6-05 二叉树的先序、中序、后序遍历
    - 6-06 二叉树由遍历确定一棵树

<!-- /MarkdownTOC -->

## 一、引入概念
**Python兵法**  
看题:  
如果 a+b+c=1000，且 a^2+b^2=c^2（a,b,c 为自然数），如何求出所有a、b、c可能的组合?

### 1-01算法引入
- 解法1:枚举法  

```python
import time

start_time = time.time()
for a in range(0,1001):
    for b in range(0,1001):
        for c in range(0,1001):
            if a+b+c == 1000 and a**2 + b**2 == c**2:
                print("a,b,c:%d,%d,%d"%(a,b,c))

end_time = time.time()
print("time:%d"%(end_time-start_time))
print("pao wan la...")
```
<img src="/picturesWork/the_art_of_war_python/01.png">

运行时间为80多秒,这跟计算机CPU等配置有关.  

- 算法提出:  
    - 算法是计算机处理信息的本质，因为计算机程序本质上是一个算法来告诉计算机确切的步骤来执行一个指定的任务。一般地，当算法在处理信息时，会从输入设备或数据的存储地址读取数据，把结果写入输出设备或某个存储地址供以后再调用。
    **算法是独立存在的一种解决问题的方法和思想。对于算法而言，实现的语言并不重要，重要的是思想。**

    - 算法的五大特性
        1. 输入: 算法具有0个或多个输入.
        2. 输出: 算法至少有1个或多个输出.
        3. 有穷性:算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成.
        4. 确定性：算法中的每一步都有确定的含义，不会出现二义性.
        5. 可行性：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成.

<!-- <table><tr><td bgcolor="#D1EEEE"><font  size="4" color="#dd00dd">一万年太久,只争朝夕</font></td></tr></table> -->
<font  size="4" color="#dd00dd" face="楷体">一万年太久,只争朝夕</font>

```python
import time

start_time = time.time()

for a in range(0,1001):
    for b in range(0,1001):
        c = 1000 - a - b
        if a**2 + b**2 == c**2:
            print("a,b,c:%d,%d,%d"%(a,b,c))

end_time = time.time()
print("time:%d"%(end_time-start_time))
print("pao wan la...")

```
<img src="/picturesWork/the_art_of_war_python/02.png">

### 1-02 时间复杂度与大O表示法
- 我们假定计算机执行算法每一个基本操作的时间是固定的一个时间单位，那么有多少个基本操作就代表会花费多少时间单位。算然对于不同的机器环境而言，确切的单位时间是不同的，但是对于算法进行多少个基本操作（即花费多少时间单位）在规模数量级上却是相同的，由此可以忽略机器环境的影响而客观的反应算法的时间效率。

- 对于算法的时间效率，我们可以用“大O记法”来表示。

### 1-03-最坏时间复杂度与计算规则
- 最坏时间复杂度:分析算法时，存在几种可能的考虑：  
    算法完成工作最少需要多少基本操作，即最优时间复杂度  
    算法完成工作最多需要多少基本操作，即最坏时间复杂度  
    算法完成工作平均需要多少基本操作，即平均时间复杂度  

- 时间复杂度的几条基本计算规则:
    - 基本操作，即只有常数项，认为其时间复杂度为$O(1)$.
    - 顺序结构，时间复杂度按加法进行计算.
    - 循环结构，时间复杂度按乘法进行计算.
    - 分支结构，时间复杂度取最大值.
    - 判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略.
    - 在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度.

- 分析上述两种解法的时间复杂度:  
$$T_1(n) = O(n ^3)$$  
$$T_2(n) = O(n ^2)$$

### 1-04-常见时间复杂度与大小关系

执行次数函数举例   |   阶  
-----   |  ----
    $12$ |  $O(1)$
    $2n+3$ |  $O(n)$
    $3n^2+2n+1$ |  $O(n^2)$
    $5log_2 n +20$ |  $O(logn)$
    $2n+3nlog_2 n +19$ |  $O(nlogn)$
    $6n^3+2n^2+3n+2$ |  $O(n^3)$
    $2^n$ |  $O(2^n)$

<br>注意:经常将$log_2 n $ 写成$logn $.
<!-- <font  size="4" color="#dd0000">$O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$</font> -->
<br>常见复杂度之间关系:
<table><tr><td bgcolor="#D1EEEE"><font  size="4" color="#dd0000">$O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$</font> </td></tr></table>

### 1-05-代码执行时间测量模块
- 利用 **timeit** 模块  
    ```python
        class timeit.Timer(stmt='pass', setup='pass', timer=<timer function>)
    ```
    <br>Timer是测量小段代码执行速度的类。
    <br>stmt参数是要测试的代码语句（statment）；
    <br>setup参数是运行代码时需要的设置；
    <br>timer参数是一个定时器函数，与平台有关。  
 
    ```python
    timeit.Timer.timeit(number=1000000)
    ```
    Timer类中测试语句执行速度的对象方法。number参数是测试代码时的测试次数，默认为1000000次.

- list操作测试

    ```python
    def test1():
       l = []
       for i in range(1000):
          l = l + [i]

    def test2():
       l = []
       for i in range(1000):
          l.append(i)

    def test3():
       l = [i for i in range(1000)]

    def test4():
       l = list(range(1000))

    from timeit import Timer

    t1 = Timer("test1()", "from __main__ import test1")
    print("concat ",t1.timeit(number=1000), "seconds")

    t2 = Timer("test2()", "from __main__ import test2")
    print("append ",t2.timeit(number=1000), "seconds")

    t3 = Timer("test3()", "from __main__ import test3")
    print("comprehension ",t3.timeit(number=1000), "seconds")

    t4 = Timer("test4()", "from __main__ import test4")
    print("list range ",t4.timeit(number=1000), "seconds")

    ```
    <img src="/picturesWork/the_art_of_war_python/03.png">

- pop操作测试

    ```python
    from timeit import Timer
    x = list(range(2000000)) #注意此处range 返回的是对象 ,要转变为lsit
    pop_zero = Timer("x.pop(0)","from __main__ import x")
    print("pop_zero ",pop_zero.timeit(number=1000), "seconds")
    x = list(range(2000000))
    pop_end = Timer("x.pop()","from __main__ import x")
    print("pop_end ",pop_end.timeit(number=1000), "seconds")

    ```
    <img src="/picturesWork/the_art_of_war_python/04.png">

    从结果可以看出，pop最后一个元素的效率远远高于pop第一个元素.

<!-- 
<pre name="code" class="c++" face="Consolas"> 
　#include &lt;stdio.h> 
　#include &lt;cstring> 
　#include &lt;cstdio&gt; 
　 int main(int argc, char const *argv[])　 
　 { 
　　 int a = 1; 
　　 String str = "abc"; 
　 　scanf("%d", &a); 
　 cout &lt;&lt;"str:"&lt;&lt; str &lt;&lt; endl; 
　　　return 0; 
　　} 
</pre> -->

<!-- ### 1-06-Python列表类型不同操作的时间效率 -->

### 1-07-Python列表与字典操作的时间复杂度
- list 内置操作时间复杂度

    Operation   |   Big-O Efficiency  
    -----   |  ----
    index x[] |  $O(1)$
    index assignment |  $O(1)$
    append |  $O(1)$
    pop()  |  $O(1)$
    pop(i) |  $O(n)$
    insert(i,item) |  $O(n)$
    del operator |  $O(n)$
    iteration(迭代) |  $O(n)$
    contains(in) |  $O(n)$
    get slice[x:y] |  $O(k),k=y-x$
    del slice   |  $O(n)$
    set slice |  $O(n+k)$
    reverse |  $O(n)$
    concatenate |  $O(k)$
    sort |  $O(nlogn)$
    multiply |  $O(nk)$

- dict 内置操作时间复杂度

    Operation  |  Big-O Efficiency
    -------    |  -----
    copy       |    $O(n)$
    get item       |    $O(1)$
    set item       |    $O(1)$
    delete item    |    $O(1)$
    contains(in)   |    $O(1)$
    iteration      |    $O(n)$



### 1-08-数据结构引入
- 数据结构
    我们如何用Python中的类型来保存一个班的学生信息？ 如果想要快速的通过学生姓名获取其信息呢？

    实际上当我们在思考这个问题的时候，我们已经用到了数据结构。列表和字典都可以存储一个班的学生信息，但是想要在列表中获取一名同学的信息时，就要遍历这个列表，其时间复杂度为O(n)，而使用字典存储时，可将学生姓名作为字典的键，学生信息作为值，进而查询时不需要遍历便可快速获取到学生信息，其时间复杂度为O(1)。

    我们为了解决问题，需要将数据保存下来，然后根据数据的存储方式来设计算法实现进行处理，那么数据的存储方式不同就会导致需要不同的算法进行处理。我们希望算法解决问题的效率越快越好，于是我们就需要考虑数据究竟如何保存的问题，这就是数据结构。

    在上面的问题中我们可以选择Python中的列表或字典来存储学生信息。列表和字典就是Python内建帮我们封装好的两种数据结构。

- 概念
    数据是一个抽象的概念，将其进行分类后得到程序设计语言中的基本类型。如：int，float，char等。数据元素之间不是独立的，存在特定的关系，这些关系便是结构。数据结构指数据对象中数据元素之间的关系。

    Python给我们提供了很多现成的数据结构类型，这些系统自己定义好的，不需要我们自己去定义的数据结构叫做Python的内置数据结构，比如列表、元组、字典。而有些数据组织方式，Python系统里面没有直接定义，需要我们自己去定义实现这些数据的组织方式，这些数据组织方式称之为Python的扩展数据结构，比如栈，队列等。

- 算法与数据结构的区别
    - 数据结构只是静态的描述了数据元素之间的关系。
    - 高效的程序需要在数据结构的基础上设计和选择算法。
    - 程序 = 数据结构 + 算法

    **总结：算法是为了解决实际问题而设计的，数据结构是算法需要处理的问题载体**

- 抽象数据类型(Abstract Data Type)
    抽象数据类型(ADT)的含义是指一个数学模型以及定义在此数学模型上的一组操作。即把数据类型和数据类型上的运算捆在一起，进行封装。引入抽象数据类型的目的是把数据类型的表示和数据类型上运算的实现与这些数据类型和运算在程序中的引用隔开，使它们相互独立。

- 最常用的数据运算有五种：
    - 插入
    - 删除
    - 修改
    - 查找
    - 排序


## 二、顺序表
在程序中，经常需要将一组（通常是**同为某个类型的**）数据元素作为整体管理和使用，需要创建这种元素组，用变量记录它们，传进传出函数等。一组数据中包含的元素个数可能发生变化（可以增加或删除元素）。

对于这种需求，最简单的解决方案便是将这样一组元素看成一个序列，用元素在序列里的位置和顺序，表示实际应用中的某种有意义的信息，或者表示数据之间的某种关系。

这样的一组序列元素的组织形式，我们可以将其抽象为**线性表**。一个线性表是某类元素的一个集合，还记录着元素之间的一种顺序关系。线性表是最基本的数据结构之一，在实际程序中应用非常广泛，它还经常被用作更复杂的数据结构的实现基础。

根据线性表的实际存储方式，分为两种实现模型：
- **顺序表**,将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。
- **链表**，将元素存放在通过链接构造起来的一系列存储块中。

### 2-01 内存、类型本质、连续存储 
<img src="/picturesWork/the_art_of_war_python/05.jpeg">

### 2-02 基本顺序表与元素外围顺序表 
<img src="/picturesWork/the_art_of_war_python/06.jpeg">

### 2-03 顺序表的一体式结构与分离式结构 
<img src="/picturesWork/the_art_of_war_python/07.jpeg">

### 2-04 顺序表数据区替换与扩充 
- 一体式结构由于顺序表信息区与数据区连续存储在一起，所以若想更换数据区，则只能整体搬迁，即整个顺序表对象（指存储顺序表的结构信息的区域）改变了。

- 分离式结构若想更换数据区，只需将表信息区中的数据区链接地址更新即可，而该顺序表对象不变。

- 元素存储区扩充
    采用分离式结构的顺序表，若将数据区更换为存储空间更大的区域，则可以在不改变表对象的前提下对其数据存储区进行了扩充，所有使用这个表的地方都不必修改。只要程序的运行环境（计算机系统）还有空闲存储，这种表结构就不会因为满了而导致操作无法进行。人们把采用这种技术实现的顺序表称为动态顺序表，因为其容量可以在使用中动态变化。

- 扩充的两种策略

    - 每次扩充增加固定数目的存储位置，如每次扩充增加10个元素位置，这种策略可称为线性增长。
      特点：节省空间，但是扩充操作频繁，操作次数多。

    + 每次扩充容量加倍，如每次扩充增加一倍存储空间。
      特点：减少了扩充操作的执行次数，但可能会浪费空间资源。以空间换时间，推荐的方式。

### 2-05 顺序表的操作
- 增加元素
<img src="/picturesWork/the_art_of_war_python/08.png">
<br>a. 尾端加入元素，时间复杂度为$O(1)$
<br>b. 非保序的加入元素（不常见），时间复杂度为$O(1)$
<br>c. 保序的元素加入，时间复杂度为$O(n)$

- 删除元素
<img src="/picturesWork/the_art_of_war_python/09.png">
<br>a. 删除表尾元素，时间复杂度为$O(1)$
<br>b. 非保序的删除元素（不常见），时间复杂度为$O(1)$
<br>c. 保序的元素删除，时间复杂度为$O(n)$

### 2-06 Python中的顺序表
- Python中的list和tuple两种类型采用了顺序表的实现技术，具有前面讨论的顺序表的所有性质。
- tuple是不可变类型，即不变的顺序表，因此不支持改变其内部状态的任何操作，而其他方面，则与list的性质类似。
- list的基本实现技术
<br>Python标准类型list就是一种元素个数可变的线性表，可以加入和删除元素，并在各种操作中维持已有元素的顺序（即保序），而且还具有以下行为特征：
    - 基于下标（位置）的高效元素访问和更新，时间复杂度应该是O(1)；
    - 为满足该特征，应该采用顺序表技术，表中元素保存在一块连续的存储区中。
    - 允许任意加入元素，而且在不断加入元素的过程中，表对象的标识（函数id得到的值）不变。
    - 为满足该特征，就必须能更换元素存储区，并且为保证更换存储区时list对象的标识id不变，只能采用分离式实现技术。

    *在Python的官方实现中，**list就是一种采用分离式技术实现的动态顺序表**。这就是为什么用list.append(x) （或 list.insert(len(list), x)，即尾部插入）比在指定位置插入元素效率高的原因。*  

    *在Python的官方实现中，list实现采用了如下的策略：在建立空表（或者很小的表）时，系统分配一块能容纳8个元素的存储区；在执行插入操作（insert或append）时，如果元素存储区满就换一块4倍大的存储区。但如果此时的表已经很大（目前的阀值为50000），则改变策略，采用加一倍的方法。引入这种改变策略的方式，是为了避免出现过多空闲的存储位置。*

## 三、链表
### 3-01 链表的提出


### 3-02 单链表的ADT模型


### 3-03 Python中变量标识的本质


### 3-04 单链表及结点的定义代码


### 4-05 单链表的判空、长度、遍历与尾部添加结点的代码实现

### 3-06 单链表尾部添加和在指定位置添加

### 3-07 单链表查找和删除元素

### 3-08 单链表与顺序表的对比

### 3-09 单向循环链表遍历和求长度

### 3-10 单向循环链表添加元素

### 3-11 单向循环链表删除元素

### 3-12 单向循环链表删除元素复习及链表扩展

### 3-13 双向链表及添加元素

### 3-14 双向链表删除元素


## 四、栈
### 4-01 栈与队列的概念


### 4-02 栈的实现


### 4-03 队列与双端队列的实现



## 五、排序与搜索
### 5-01 排序算法的稳定性


### 5-02 冒泡排序及实现


### 5-03 选择排序算法及实现

### 5-04 插入算法


### 5-05 插入排序


### 5-06 插入排序2

### 5-07 希尔排序


### 5-08 希尔排序实现


### 5-09 快速排序

### 5-10 快速排序实现1-1

### 5-10 快速排序实现1

### 5-11 快速排序实现2

### 5-12 归并排序

### 5-13 归并排序 代码执行流程

### 5-14 归并排序时间复杂度及排序算法复杂度对比

### 5-15 二分查找

### 5-16 二分查找时间复杂度


## 六、树和树的算法
### 6-01 树的概念

### 6-02 二叉树的概念

### 6-03 二叉树的广度优先遍历

### 6-04 二叉树的实现

### 6-05 二叉树的先序、中序、后序遍历

### 6-06 二叉树由遍历确定一棵树
